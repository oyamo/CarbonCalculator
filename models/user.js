const crypto = require("crypto")

const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
// Define the user Schema
const userSchema = mongoose.Schema({
    firstName: {
        type: String,
        required: true
    },

    lastName: {
        type: String,
        required: true
    },
    telephone:{
      type: String,
        required: true
    },

    state:{
        type: String
    },

    country:{
        type: String
    },

    email: {
        type: String,
        required: true,
        trim: true,
        unique: 1
    },
    age:{
        type: Number
    },
    address: {
        type:String
    },
    Authorization: {
        type: String
    },

    refreshToken: {
        type: String
    },

    resetToken: {
        type: String
    },
    password:  {
        type: String
    }
},{
    timestamps: true
});


/**
 * Initialise Authorization Bearer Token
 */
userSchema.pre('save', function (next) {
    const user = this;
    if(user.isModified('password')){
        user.Authorization = jwt.sign(
            {
                userId: user._id.toHexString()
            },
            process.env.SECRET,
            {
                algorithm: 'HS256',
                expiresIn: process.env.TOKEN_LIFE
            }
        );
        user.refreshToken = jwt.sign(
            {
                userId: user._id.toHexString()
            },
            process.env.REFRESH_TOKEN_SECRET,
            {
                algorithm: 'HS256',
                expiresIn: process.env.REFRESH_TOKEN_LIFE
            }
        );

        user.password = bcrypt.hashSync(user.password, 10);
        next();
    }else{
        next();
    }
});


/**
 * Try logging in using Password
 * @param password
 * @returns {Promise<unknown>}
 */
userSchema.methods.attemptLogin = function (password) {
    const hash = this.password;
    return new Promise((resolve, reject) => {
        const match = bcrypt.compareSync(password, hash);
        resolve(match);
    })
};


/**
 * Try find user using JWT
 * @param token
 * @returns {Promise<unknown>}
 */
userSchema.statics.findByJWTToken = function (token) {
    const user = this;
    return new Promise((resolve, reject) => {
        try{
            jwt.verify(token, process.env.SECRET, (err, decode) => {
                if (!err) {
                    user.findOne({_id: decode.userId || '', token: token}, (err, user) => {
                        if (err == null) {
                            resolve(user);
                        } else {
                            reject(err);
                        }
                    })
                } else {
                    reject(err);
                }
            });
        }catch (e) {
            reject(e.message)
        }

    })
};


/**
 * Deletes user token when the user would like to log out
 * @returns {Promise<User>}
 */
userSchema.methods.clearJWTToken = function () {
    const user = this;
    return new Promise((resolve, reject) => {
        user.update({$unset: {token: 1}}, (err, user) => {
            if (!err) {
                resolve(user);
            } else {
                reject(err);
            }
        });
    })
};

userSchema.methods.generateToken = function () {
    const user = this;
    user.Authorization = jwt.sign(
        {
            userId: user._id.toHexString()
        },
        process.env.SECRET,
        {
            algorithm: 'HS256',
            expiresIn: process.env.TOKEN_LIFE
        }
    );
    user.refreshToken = jwt.sign(
        {
            userId: user._id.toHexString()
        },
        process.env.REFRESH_TOKEN_SECRET,
        {
            algorithm: 'HS256',
            expiresIn: process.env.REFRESH_TOKEN_LIFE
        }
    );

   return new Promise((resolve, reject) => {
       user.save((err, user)=>{
           if(err) {
               reject(err)
           } else {
               resolve(user)
           }
       })
   })
}
/**
 *  Generates reset password token that expires after a given time.
 * @returns {Promise<void>}
 */
userSchema.methods.generateResetPasswordToken = async function (){
    const user = this;
    const  email = user.email;

    const randomBytes = crypto.pseudoRandomBytes(32);
    user.resetToken = jwt.sign(
        {
            randToken: randomBytes.toString('base64')
        },
        process.env.RESET_TOKEN,
        {
            algorithm: 'HS256',
            expiresIn: process.env.RESET_LIFE
        }
    );
    user.save((err, user)=>{

    })
}

/**
 * Resets a password
 * @param password - The new Password
 * @param token - Token used to resetPassword.Was generated by `User.methods.generatePasswordToken`
 * @returns {Promise<Number>}
 */
userSchema.methods.changePassword = function (password, token){
    return new Promise((resolve, reject )=> {
        jwt.verify(token, process.env.SECRET, (err, decode) => {
            if(!err){
                this.updateOne(
                    {resetToken: token}, {passWord: bcrypt.hashSync(password, 10)},
                    (err, doc) => {
                        if (err) {
                            reject(err)
                        } else {
                            resolve(1);
                        }
                    }
                );
            }else{
                reject(err)
            }
        });
    });
}


const User = mongoose.model('User', userSchema);
module.exports = User;